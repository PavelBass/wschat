# Rambler Task - Chat Server on WebSocket

## Задание
```
Домашнее задание состоит в написании сервера чат-комнат.
Хочу получить саму примитивную программу, к которой можно подсоединится по TCP или по WebSocket.

Сервер должен поддерживать команды:
LOGIN NICK - залогинится с ником
JOIN ROOM - войти в комнату (начать получать сообщения от этой комнаты тоже)
LEFT ROOM - выйти из комнаты

Я решил не ограничивать тебя в выборе фреймворка (Twisted, Tornado, etc..).
Остальной протокол общения оставляю на тебя.

Из возможныйх плюсов:
1. Сохранение истории комнат
2. Регистрация и логин с паролем

Также хочу увидеть простенький клиент, документацию по протоколу.

Ссылку на репозиторий прошу прислать сразу же, как ты его создашь.

Весь исходный код вместе с документацией выложить на GitHub или BitBucket.
Срок исполнения тестового задания - понедельник (25 мая 2015). 
```

## Решение

Для реализации сервера выбран [Tornado framework](http://www.tornadoweb.org/ "Торнадо фреймворк").

### 1. Протоколы

Запущенный сервер предоставляет html страницу (HTTP [RFC 2616](https://tools.ietf.org/html/rfc2616 "Hypertext Transfer Protocol -- HTTP/1.1")) с реализацией клента (JavaScript), расположенную в корне ('/') запущенного сервера. WebSocket протокол [(RFC 6455)](http://tools.ietf.org/html/rfc6455 "The WebSocket Protocol") предоставляется по пути '/chat' адреса запущенного сервера.

### 2. Аутентификация

Аутентификация пользователей, в первую очередь, происходит на основании записи 'user' в cookies. Открытое соединение по протоколу WebSocket хранит собственное значение для аутентификации пользователя, таким образом возможно авторизовываться любыми пользователями и разлогиниваться за период соединения, вне зависимости от записи в cookies. Но, при потере соединения и создании нового, пользователь будет аутентифицирован на основании записи 'user' в cookies.

Пользователь, которого не может распознать сервер, равно как и вновь созданный пользователь, автоматически подключаются к комнате "Free Chat". Неаутентифицированный пользователь не может подключиться к другой комнате, но может отсоединяться (left room) и присоединяться (join room) к комнате "Free Chat". Все сообщения всех неаутентифицированных пользователей подписываются за единым пользователем 'Anonymous'.

### 3. Передача сообщений

Сообщения от клиента к серверу передаются utf-8 строкой [(RFC 3629)](http://tools.ietf.org/html/rfc3629 "UTF-8, a transformation format of ISO 10646"), без какой-либо предварительной обработки.
Сообщения от сервера к клиенту передаются utf-8 строкой в формате **{TYPE}:{TEXT}**
Где: **TYPE** - тип передаваемого сообщения, из перечисленных ниже:

1. **SERVER** - В этом случае за разделителем ':' идет текстовое сообщение, переданное индивидуально пользователю. В общем случае это реакция сервера на команды пользователя, сообщения о присоединении / отсоединении от комнаты и т.п. Например ***```SERVER:You are connected to room: &quot;Free Chat&quot;```***
2. **MESSAGE** - В этом случае за разделителем ':' идет сообщение отправленное другими пользователями в комнату. Полный вид сообщения в этом случае **MESSAGE:[{ROOM}] {AUTHOR}: {TEXT}**. Например ***```MESSAGE:[Free Chat] Bender: I'm gonna build my own amusement park. But with gambling and hookers! Ah, forget the amusement park.```***

Типы сообщений реализованы для того, чтобы клиент мог отличить сообщения сервера от сообщений пользователей.

### 4. Поддерживаемые команды

Если строка начинается с символа '#' (без пробелов слева), сервер пытается распознать её, как команду. Команды (но не аргументы) приводятся к нижнему регистру, поэтому регистр команды не имеет значения. Аргументы должны быть разделены пробелами. Поддерживаются следующие команды:

1. **login {USER_NAME} {PASSWORD}** - авторизует в системе на период поддержания соединения.
2. **logout** - деавторизует пользователя на период поддержания соединения.
3. **register {USER_NAME} {PASSWORD}** - регистрирует нового пользователя с логином **{USER_NAME}** и паролем **{PASSWORD}**. Повторный ввод пароля не запрашивается. Авторизация под новым пользователем, после его создания, не просиходит. Для авторизации под вновь созданным пользователем, необходимо использовать соответствующую команду.
4. **join room {ROOM_NAME} {NICKNAME}** **(в разработке)** - присоединяет пользователя к выбранной комнате, при этом он остается в комнате/комнатах, к которым был присоединен до этого. Сообщение отправленное пользователем будет приходить во все комнаты, к которым он присоединен, под тем никнеймом, с которым он зарегистрирован в каждой комнате.
5. **left room {ROOM_NAME} {NICKNAME}** **(в разработке)** - отсоединяет пользователя от комнаты.
6. **change nick {ROOM_NAME} {NICKNAME}** **(в разработке)** - изменяет никнейм пользователя в указанной комнате. Все последующие сообщения пользователя в этой команте будут подписаны новым никнеймом. При указании "\*" в качестве имени комнаты, никнейм пользователя будет изменени во всех группах, к которым он присоединен.

### 5. База Данных

Для реализации "бонусного" сохранения истории и зарегистрированных пользователей вне работы сервера, добавлена поддержка REDIS. Эта БД и блокирующая библиотека для рабты с ней были выбранны потому, что у испытуемого из баз данных был установлен только REDIS, а чтение документации по асинхронным библиотекам, пробы и реализация, сделают невозможным уложиться в установленный срок. Так как это "простейший сервер" и ограничений по исопльзованию библиотек нет, считаю приемлимым использование любой базы данных.

При инициализации сервера совершаются:

1. Попытка импортировать модуль redis ([redis-py](https://github.com/andymccurdy/redis-py))
2. Поптыка подключиться к REDIS (host='localhost', port=6379, db=0)

В случае неудачи, в качестве интерфейса базы данных используется класс, хранящий значения в оперативной памяти с использованием python структур данных. В этом случае, при остановке сервера, сохраненная информация будет потеряна.

Если импорт и подключение к REDIS увенчались успехом, используется класс, работающий с REDIS **(в разработке)**. В этом случае сохраненные данные будут независимы от работы/неработы сервера.

Все ключи, создаваемые сервером в REDIS, начинаются с префикса "RamblerTaskChat:".
